**데이터 구조** : 여러 데이터를 효과적으로 사용 관리하기 위한 구조 **(str, list, dict 등)**

- 데이터를 효율적으로 정리하고 관리하기 위한 ‘정리함’ → **목적에 맞게 데이터를 담아두는 방식**

**자료구조** : 각 데이터의 효율적인 저장, 관리를 위한 구조를 나눠 놓은 것

- 단순히 데이터를 묶는 것을 넘어, 프로그램의 성능과 효율성, 유지보수성에 큰 영향을 미치는 핵심적인 개념

**메서드** : 문자열, 리스트, 딕셔너리 등 **각 데이터 구조의 메서드를 호출**하여 **다양한 기능을 활용**하기

## 메서드

**메서드 method** : **객체에 속한 함수**. 프로그래밍에서 메서드(method)는 객체가 특정 작업을 수행하도록 정의된 함수.

- 문자열, 리스트, 딕셔너리 등 파이썬의 다양한 데이터 구조는 **저마다 고유한 메서드**를 가짐
- 해당 데이터 구조의 데이터를 **효율적으로 조작**하거나 **특정 기능을 수행**하기 위해 제공됨
- **클래스 (class) 내부에 정의되는 함수**
    - 클래스 : 파이썬에서 ‘**타입을 표현하는 방법**’
        - ex) `help` 함수를 통해 `str` 을 호출해보면 `class` 였다는 것을 확인 가능

* **객체 (object)** : **특정 데이터(정보)**와 **그 데이터를 처리하는 기능(메서드)**를 **하나**로 묶은 것

메서드 호출 방법 : 우리가 만든 객체(데이터)에게 원하는 명령(메서드)을 내리는 방법. **`데이터 타입 객체.메서드()`**

![image.png](attachment:8271099e-ab7a-45ab-9d3e-710189e07364:image.png)

## 시퀀스 데이터 구조

### 문자열

문자열 **조회/탐색 및 검증** 메서드 : 

- **`s.find(x)`**  : **x의 첫 번째 위치**를 반환. **없으면, -1을 반환**
- **`s.index()`** : **x의 첫 번째 위치**를 반환. **없으면, 오류 발생**
- **`s.isupper()`** : 문자열 내 의 **모든 문자가 대문자**인지 확인
- **`s.islower()`** : 문자열 내의 **모든 문자가 소문자**인지 확인
- **`s.isalpha()`** : 문자열 내의 모든 문자가 알파벳인지 확인 (단순 알파벳이 아닌 유니코드 상 Letter (한국어도 포함))

문자열 **조작** 메서드 : 새로운 문자열 반환

- **`s.replace(old, new[,count])`** : **바꿀 대상 글자**를 **새로운 글자로 바꿔서 변환**
    - `[ ]` : 선택 인자
    - `[, count]` : 바꿀 글자 수
- **`s.strip([chars])`** : 문자열의 **시작과 끝에 있는 공백이나 특정 문자를 제거**
    - `[chars]` : 지정한 문자
- **`s.split(sep=None, maxsplit=-1)`** : **sep을 구분자 문자열로 사용**하여 문자열에 있는 단어들의 **리스트를 반환**
- **`‘seperator’.join(iterable)`** : 구분자로 iterable의 문자열을 연결한 문자열을 반환
    - iterable : 순서대로 꺼내 쓸 수 있는 데이터들의 묶음
    - `'seperator'` : 구분자
- `s.capitalize()` : 가장 첫 번째 글자를 대문자로 변경
- `s.title()` : 문자열 내 띄어쓰기 기준으로 각 단어의 첫 글자는 대문자로, 나머지는 소문자로 변환
- `s.upper()` : 모두 대문자로 변경
- `s.lower()` : 모두 소문자로 변경
- `s.swapcase()` : 대 ↔ 소문자 서로 변경

### 리스트

리스트 **값 추가 및 삭제** 메서드 : 원본을 조작함 > 반환값이 없음

- **`l.append(x)`** : 리스트 **마지막에 항목 x를 추가**
- **`l.extend(iterable)`** : 리스트에 **다른 반복 가능한 객체의 모든 항목들**을 리스트 **끝에 추가** (+=과 같은 기능)
    - `append()` 와 비교
    
    ```python
    my_list.append([5,6,7])
    print(my_list) # [1, 2, 3, 4, 5, 6, [5, 6, 7])
    ```
    
    - 반복 가능한 객체가 아니면 추가 불가
    
    ```python
    my_list.extend(100) # TypeError: 'int' object is not iterable
    ```
    
- `l.insert(i, x)`: 리스트의 **지정한 인덱스 i**에 **항목 x를 삽입**
- `l.remove(x)` : 리스트 가장 왼쪽에 있는 항복(첫 번째) x를 제거. 항목이 존재하지 않을 경우, ValueError
- **`l.pop()`** : 리스트 **가장 오른쪽에 있는 항목(마지막)을 *반환* 후 제거**
- **`l.pop(i)`** : 리스트의 **인덱스 i에 있는 항목을 *반환* 후 제거**
- `l.clear()` : 리스트의 모든 항목 삭제

리스트 **탐색 및 정렬** 메서드 : 

- `l.index(x)` : 리스트에서 **첫 번째로 일치**하는 **항목 x의 인덱스를 반환**
- `l.count(x)` : 리스트에서 **항목 x의 개수를 반환**
- **`l.reverse()`** : 리스트의 **순서를 역순으로 변경** (정렬 x) (원본 리스트를 변경하며, None을 반환함)
- **`l.sort()`** : 리스트를 **정렬 (매개변수 이용가능)**(원본 리스트를 변경하며, None을 반환함)
    - `(reverse = False)` 가 기본 매개변수

[다양한 리스트 메서드](https://docs.python.org/3.11/tutorial/datastructures.html#data-structures)

## 복사

### 객체와 참조

**가변 객체 (mutable)** : 생성 후 내용을 **변경할 수 있는 객체**. **list, dict, set**

- 생성 후에도 그 내용을 수정할 수 있음
- 객체의 내용이 변경되어도 같은 메모리 주소를 유지

**불변 객체 (immutable**) : 생성 후 **내용을 변경할 수 없는 객체**. **int, float, str, tuple**

- 생성 후 그 값을 변경할 수 없음
- 새로운 값을 할당하면 새로운 객체가 생성되고, 변수는 그 객체를 참조하게 됨


**변수 할당** : 파이썬에서 **객체에 대한 참조를 생성하는 과정**

- 변수는 객체의 메모리 주소를 가리키는 **라벨** 역할을 함
    - 메모리 참조 방식 : 변수는 객체의 ‘메모리 주소’를 저장. 여러 변수가 동일한 객체를 참조할 수 있음
- `=` 연산자를 사용하여 변수에 값을 할당
    - 할당 시 **새로운 객체가 생성**되거나 **기존 객체에 대한 참조가 생성됨**
- **새로운 객체 생성 후 참조** : 할당되는 값이 새로운 객체일 경우, 파이썬은 **먼저 해당 객체를 메모리에 만들고, 변수가 그 객체를 가리키도록 함**
- **기존 객체에 대한 참조** : **이미 메모리에 존재하는 객체**를 변수에 할당하면, **새로운 객체를 만들지 않고 해당 객체에 대한 참조만 생성함**

`id()` 함수를 사용한 메모리 주소 확인 : 

- `id()` 함수를 사용하여 객체의 메모리 주소를 확인 가능
- `is` 연산자를 통해 두 변수가 같은 객체를 참조하는지 확인 가능
    
    ```python
    x = [1, 2, 3]
    y = x
    z = [1, 2, 3]
    
    print(f'x의 id: {id(x)}') # x의 id : 1682231207424
    print(f'x의 id: {id(x)}') # y의 id : 1682231207424
    print(f'x의 id: {id(x)}') # z의 id : 1682231224896
    
    print(f'x와 y는 같은 객체인가? {x is y}') # x와 y는 같은 객체인가? True
    print(f'x와 z는 같은 객체인가? {x is y}') # x와 z는 같은 객체인가? False
    ```
    

가변/불변 메모리 관리 방식의 이유 : 

- **성능 최적화** : 객체 생성 및 삭제에 드는 비용을 절감하여 성능을 향상시킴
    - 불변 객체 : **변경이 불가능**하므로, **여러 변수가 동일한 객체를 안전하게 공유**할 수 있음
    - 가변 객체 : **내용 수정이 빈번할 때**, 새로운 객체를 생성하는 대신 **기존 객체를 직접 수정**할 수 있음
- **메모리 효율성** :
    - 불변 객체 : 동일한 값을 가진 **여러 변수가 같은 객체를 참조**할 수 있어 **메모리 사용을 최소화**할 수 있음
    - 가변 객체 : **크기가 큰 데이터를 효율적으로 수정**할 수 있음

### 얕은 복사

**얕은 복사 (shallow copy)** : **객체의 최상위 요소**만 **새로운 메모리에 복사**하는 방법, **내부에 중첩된 객체**가 있다면 **그 객체의 참조만 복사**됨

- 얕은 복사 후 중첩된 리스트나 딕셔너리 같은 **가변 객체를 수정**하면, **원본 객체와 복사본 객체가 함께 변경**됨. 복사본의 중첩 객체가 여전히 원본 객체의 중첩 객체를 참조하고 있기 때문.

**얕은 복사 구현 방법** > 1차원 리스트에서의 얕은 복사

1. 리스트 슬라이싱 **`:` 은 원본 리스트와 동일한 내용의 새로운 리스트를 만듬**
    - 새로운 리스트에 복사되는 것은 요소 자체의 값이 아니라 해당 요소들이 참조하는 주소
    
2. `copy()` 메서드 **`list.copy()` 는 원본 리스트와 동일한 내용을 가진 새로운 리스트 객체를 반환**함
    - 복사된 새 리스트의 요소들은 원본 리스트의 요소들과 동일한 객체들을 참조함
    
3. `list()` 함수
    

**얕은 복사의 한계** : 2차원 리스트와 같이 변경 가능한 객체 안에 변경 가능한 객체가 있는 경우

- a와 b의 주소는 다르지만 **내부 객체의 주소는 같기 때문에 함께 변경됨**
    
    ```python
    a = [1, 2, [3, 4, 5]]
    b = a[:]
    
    b[0] = 999
    print(a) # [1, 2, [3, 4, 5]] # 내부에 들어있는 [3, 4, 5]의 주소가 같음
    print(b) # [999, 2, [3, 4, 5]] # 내부에 들어있는 [3, 4, 5]의 주소가 같음
    
    b[2][1] = 100
    print(a) # [1, 2, [3, 100, 5]]
    print(b) # [999, 2, [3, 100, 5]]
    
    print(f'a[2]와 b[2]가 같은 객체인가? {a[2] is b[2]}') # True
    ```
    

1차원 리스트와 다차원 리스트에서의 **차이점** : 

- 1차원 리스트 : 얕은 복사로 충분히 독립적인 복사본을 만들 수 있음
- **다차원 리스트 : 최상위 리스트만 복사되고, 내부 리스트는 여전히 원본과 같은 객체를 참조**

### 깊은 복사

**깊은 복사 (deep copy)** : 객체의 **모든 수준의 요소를 새로운 메모리에 복사**하는 방법, **중첩된 객체까지 모두 새로운 객체로 생성**됨

- **`copy` 모듈에서 제공하는 `deepcopy()` 함수를 사용**
- 원본 객체와 복사본이 완전히 독립적임
- 복사본의 어떤 수준에 있는 중첩된 내용을 변경하더라도 원본 객체에는 절대 영향을 주지 않음
    
    ```python
    import copy
    new_object = copy.deepcopy(original_object)
    ```
    

```python
import copy

a = [1, 2, [3, 4, 5]]
b = copy.deepcopy(a)

b[2][1] = 100

print(a) # [1, 2, [3, 4, 5]]
print(b) # [1, 2, [3, 100, 5]]
print(f'a[2]와 b[2]가 같은 객체인가? {a[2] is b[2]}') # False
```

## List Comprehension

**List comprehension** : 간결하고 효율적인 리스트 생성 방법

- 파이썬 개발자들이 선호하는 스타일로, 코드를 더 ‘파이썬답게’ 작성하는 방법 중 하나

**List comprehension 구조 : `[표현식 for 변수 in 순회 가능한 객체 if 조건]`** 

- 표현식 : 결과 리스트에 추가될 값
- 변수 : 순회 중인 현재 요소
- 순회 가능한 객체 : 반복할 데이터
- 조건식 : 필터링 조건
- if 조건식 : 선택사항. 조건 명시 하지않을 시 모든 요소에 대해 표현식이 적용됨

**성능 비교** : 

1. list comprehension : 가장 pythonic하고 대부분의 경우 우수한 성능을 보임
2. map : 특정 상황 (int, str 등 내장 함수와 함께 사용할 때)에서 가장 빠름. 사용자가 직접 만든 함수나 lambda와 함께 사용될 때에는 list comprehension과 성능이 비슷하거나 약간 느릴 수 있음
3. for loop : 일반적으로 가장 느리다고 알려져 있지만, python 버전이 올라가면서 다른 방식과 비슷하거나 때로는 더 나은 결과를 보이기도 함. 하지만, 여러 줄에 걸친 복잡한 조건문이나 예외 처리 등이 필요할 때는 유일한 선택지이며, 그 자체로 매우 유용함

## 메서드 체이닝

메서드 체이닝 : 여러 메서드를 연속해서 호출하는 방식

- `메서드().메서드()` : 앞 메서드 반환 값으로 뒤 메서드를 동작하기 때문에, 앞 메서드 반환값이 None일 때 동작 오류

메서드 체이닝 주의사항:

1. 모든 메서드가 체이닝을 지원하는 것은 아님 : 메서드가 객체를 반환할 때만 체이닝이 가능
2. None을 반환하는 메서드는 메서드 체이닝이 불가능 
    
    ex) 리스트의 append(), sort()
    
3. 메서드 체이닝을 사용할 때는 각 메서드의 반환 값을 잘 이해하고 있어야 

## 문자 유형 판별 메서드

문자 유형 판별 메서드 : 문자열에 포함된 문자들의 유형을 판별하는 메서드

- **`isdecimal()`** : 문자열이 모두 숫자 문자(0~9)로만 이루어져 있어야 True
- **`isdigit()`** : `isdecimal()` 과 비슷하지만, 유니코드 숫자도 인식
- **`isnumeric()`** : `isdigit()` 과 유사하지만, 몇 가지 추가적인 유니코드 문자들을 인식 (분수, 지수, 루트 기호도 숫자로 인식)