## Python 기초

### List

**리스트 (list)** : **여러 개의 값을 순서대로 저장**하는, **변경 가능한 (mutable)** 시퀀스 자료형.
- 인덱싱, 슬라이싱, 길이 확인, 반복 등 시퀀스 공통 기능 모두 사용 가능.

리스트 표현 : 
- `[]` 안에 값들을 `,`로 구분하여 만듦.
- 숫자, 문자열, **다른 리스트** 등 **모든 종류의 데이터를 담을 수 있음**.
- 값을 추가, 수정, 삭제하는 등 자유롭게 변경할 수 있음.

```python
my_list = [1, 'a', 3, 'b', 5]

# 인덱싱
print(my_list[1]) # a

# 슬라이싱
print(my_list[2:4]) # [3, 'b']
print(my_list[:3]) # [1, 'a', 3]
print(my_list[3:]) # ['b', 5]
print(my_list[::2]) # [1, 3, 5]
print(my_list[::-1]) # [5, 'b', 3, 'a', 1]

# 길이
print(len(my_list)) # 5
```

**중첩 리스트 (nested list)** : 다른 리스트를 값으로 가진 리스트
- 중첩 (nested) : 어떤 자료 구조 안에 같은 종류의 자료 구조가 포함된 형태

중첩 리스트 접근하기 : 인덱스를 연달아 사용하여 안쪽 리스트의 값에 접근할 수 있음.
1. 먼저 바깥 리스트의 인덱스로 안쪽 리스트를 선택.
2. 선택된 안쪽 리스트에 다시 한 번 인덱스를 사용.

```python
my_list = [1, 2, 3, 'Python', ['hello', 'world', '!!!']]

print(len(my_list))    # 5
print(my_list[4][-1])  # !!!
print(my_list[-1][1][0]) # w > 리스트 안 문자열까지 접근가능
```

리스트의 **가변성** : 한 번 생성된 리스트는 "그 내용을 자유롭게 **수정, 추가, 삭제**할 수 있다"는 뜻.
- 가변성 (mutability) : 생성된 후에도 그 내용(값)을 변경할 수 있는 성질.
- 인덱싱, 슬라이싱 등으로 **값 수정 가능**.

```python
# 리스트는 가변
# 1. 인덱싱으로 값 수정
my_list = [1, 2, 3, 4, 5]
my_list[1] = 'two'
print(my_list)  # [1, 'two', 3, 4, 5]

# 2. 슬라이싱으로 값 수정
my_list = [1, 2, 3, 4, 5]
my_list[2:4] = ['three', 'four'] # ['three', 'four', 'five']
print(my_list)  # [1, 2, 'three', 'four', 5] > [1, 2, 'three', 'four', 'ssafy', 5] 슬라이싱과 같은 수가 아니어도 됨.
```

### Tuple

**튜플 (tuple)** : **여러 개의 값을 순서대로 저장**하는 **변경 불가능**한 시퀀스 자료형.
- 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용할 수 있음.

```python
my_tuple = (1, 'a', 3, 'b', 5)

# 인덱싱
print(my_tuple[1]) # a

# 슬라이싱
print(my_tuple[2:4])   # (3, 'b')
print(my_tuple[:3])    # (1, 'a', 3)
print(my_tuple[3:])    # ('b', 5)
print(my_tuple[::2])   # (1, 3, 5)
print(my_tuple[::-1])  # (5, 'b', 3, 'a', 1)

# 길이
print(len(my_tuple)) # 5
```

튜플 표현 : 
  - `()` 안에 값들을 `,`로 구분하여 만듦. 소괄호 없이도 만들 수 있음.
  - 모든 종류의 데이터를 담을 수 있음.
  - 리스트와 거의 비슷하지만, **한 번 만들어지면 절대 수정할 수 없음**.
  - **단일 요소 튜플 생성**시, **반드시 후행 쉼표 (trailing comma)를 사용**해야 함.

```python
my_tuple_1 = ()
my_tuple_2 = (1,) # `,`이 없으면 튜플이 아님 (요소가 1개일 때)
my_tuple_3 = (1, 'a', 3, 'b', 5)
my_tuple_4 = 1, 'hello', 3.14, True
```

튜플의 **불변성** : 한 번 생성된 튜플은 그 내용을 절대 수정, 추가, 삭제할 수 없음.
- 불변 특성을 사용하여 내부 동작과 안전한 데이터 전달에 사용됨.
- 다중 할당, 값 교환, 함수 다중 반환 값 등 > 데이터의 '안정성과 무결성'을 보장함.
- 파이썬이 내부적으로 동작 시, 자체 사용

### Range

**range** : **연속된 정수 시퀀스를 생성**하는 **변경 불가능**한 (immutable) 자료형
- 주로 반복문과 함께 사용되며, 특정 횟수만큼 코드를 반복 실행할 때 매우 유용함.
- 시작 값, 끝 값, 간격이라는 '규칙'만 기억하여 메모리를 매우 효율적으로 사용함.

range 기본 구문 : `range()`는 **1개, 2개 또는 3개의 매개변수(인자)**를 가질 수 있음.    
- 매개변수 : 함수를 정의할 때, **함수가 받을 값을 나타내는 변수**
- 인자 : 함수를 호출할 때, 실제로 전달되는 값
- list로 형변환 시, 내부 값을 확인할 수 있음.
- 시작 값, 끝 값, 간격이라는 '규칙'만 기억하여 메모리를 효율적으로 사용함.

`range(start, stop, step)`
- `range(stop)` : 매개변수가 하나면 stop으로 인식. start은 0이, step은 1이 기본값.
- `range(start, stop)` : 매개변수가 2개면 start와 stop으로 인식. step은 1이 기본값.
- `range(start, stop, step)` : 모든 매개변수를 직접 지정.

```python
my_range_1 = range(5)
my_range_2 = range(1, 10)
my_range_3 = range(5, 0, -1)

print(my_range_1) # range(0, 5)
print(my_range_2) # range(1, 10)
print(my_range_3) # range(5, 0, -1)

print(list(my_range_1)) # [0, 1, 2, 3, 4]
print(list(my_range_2)) # [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(list(my_range_3)) # [5, 4, 3, 2, 1]
```
range의 규칙 : 
1. 값의 범위 규칙 : stop 값은 생성되는 시퀀스에 절대 포함되지 않음.
2. 증가/감소 값(step) 규칙 : step 값은 숫자 시퀀스의 간격과 방향을 결정
   1. step이 양수일 때 (기본값: 1) : 숫자가 start부터 stop을 향해 증가
   2. step이 음수일 때 : 숫자가 start부터 stop을 향해 감소. start 값은 stop 값보다 반드시 커야 함.

### Dict

**딕셔너리 (dict)** : **key - value 쌍**으로 이루어진 **순서와 중복이 없는 변경 가능한** 자료형.
- 데이터에 순서가 필요 없고, 각 데이터에 Key를 붙여 관리하고 싶을 때 사용함.
  - ex) 사람의 인적 정보, 게임 캐릭터의 능력치 등

딕셔너리 표현 : 
- `{}` 안에 값들이 `,`로 구분되어 있음.
- 값 1개는 키와 값이 쌍으로 이루어져 있음.
- Key (키) : 값을 식별하기 위한 고유한 '이름표' (**중복 불가**)
- Value (값) : 키에 해당하는 실제 데이터
- 각 값에는 **순서가 없음** > 입력한 순서는 출력 시 그대로 유지는 됨. 그러나 Key를 통한 접근이 딕셔너리의 핵심.*

```python
# 딕셔너리 표현
my_dict_1 = {} # 빈 딕셔너리
my_dict_2 = {'key' : 'value'}
my_dict_3 = {'apple' : 12, 'list' : [1, 2, 3]}
```

딕셔너리의 규칙 : 
- Key의 규칙 : 
  - **고유해야 함**. 중복될 수 없음.
  - **변경 불가능한 (immutable) 자료형만 사용 가능**. **str, int, float, tuple**.
- Value의 규칙 : 어떤 자료형이든 자유롭게 사용할 수 있음.

딕셔너리 값 접근 방법 : `[]`를 통해 Key를 사용하여, 해당 Value를 꺼내올 수 있음.
- **존재하지 않는 Key로 접근하면 KeyError가 발생**하며 프로그램이 멈춤.

```python
# 딕셔너리 값 추가 및 변경
my_dict = {'apple': 12, 'list': [1, 2, 3]}
# 추가
my_dict['banana'] = 50
print(my_dict)  # {'apple': 12, 'list': [1, 2, 3], 'banana': 50}

# 변경
my_dict['apple'] = 100
print(my_dict)  # {'apple': 100, 'list': [1, 2, 3], 'banana': 50}
```

### Set

**세트 (set)** : **순서와 중복이 없는 변경 가능한** 자료형.
- `{}` 안에 값들을 `,`로 구분하여 만듦.
- 수학에서의 **집합과 동일한 연산 처리 가능**.
- **중복을 허용하지 않음** : 똑같은 값은 단 하나만 존재할 수 있음.
- **순서가 없음** : 인덱싱, 슬라이싱을 사용할 수 없음.
- **비어있는 세트는 반드시 `set()` 함수**로 만들어야 함.

```python
# 세트의 집합 연산

my_set_1 = {1, 2, 3}
my_set_2 = {3, 6, 9}

# 합집합
print(my_set_1 | my_set_2) # {1, 2, 3, 6, 9}

# 차집합
print(my_set_1 - my_set_2) # {1, 2}

# 교집합
print(my_set_1 & my_set_2) # {3}
```
### None

**None** : 파이썬에서 **'값이 없음'을 표현**하는 특별한 데이터 타입.
- '값이 존재하지 않음' 또는 '아직 정해지지 않음'이라는 상태를 나타내기 위해 사용됨.
- 숫자 0이나, 빈 문자열('')과는 다름.

### Boolean

**Boolean** : **'참(True)'과 '거짓(False)'** 단 2가지 값만 가지는 데이터 타입.
- 프로그램의 흐름을 제어하는 조건문에서 '맞다' 또는 '틀리다'를 판단하는 역할을 함.

### Collection

**Collection** : **여러 개의 값을 하나로 묶어 관리하는 자료형**들을 통칭하는 말.
- 목적에 따라 다양한 종류의 컬렉션을 제공함.
- **str, list, tuple, range, set, dict 데이터 타입**이 모두 Collection에 분류됨.
* 표 중

### 형변환

**형변환 (type conversion)** : **한 데이터 타입을 다른 데이터 타입으로 변환**하는 과정. 데이터의 '형태'를 필요에 따라 바꾸는 것.
- 예시) 문자열 '100'을 숫자 100으로 바꿈. 숫자 3.14를 정수 3으로 바꿈 등
- 암시적 형변환 : **파이썬이 자동**으로 처리
- 명시적 형변환 : **개발자가 직접 지시**

**암시적 형변환 (implicit conversion)** : 파이썬이 연산 중에 자동으로 데이터 타입을 변환하는 것. 데이터 손실을 막기 위해 더 정밀한 타입으로 자동 변환해주는 규칙. '더 안전한 쪽으로' 파이썬이 자동 처리.
- 내부적으로 실수가 정수를 포함하고 있음
- 불리언 True == 1, False == 0 > 연산 시, 변환 후 계산

**명시적 형변환 (explicit conversion)** : 개발자가 변환하고 싶은 타입을 **직접 함수로 지정**하여 변환하는 것. 서로 다른 타입의 데이터를 '호환'되도록 맞추는 과정.

- 예시)    
  - `int()` : 정수로 변환    
  - `float()` : 실수로 변환    
  - `str()` : 문자열로 변환    
  - `list()` : 리스트로 변환    
  - `tuple()` : 튜플로 변환    
  - `set()` : 세트로 변환    

### 연산자

산술 연산자 : 수학적 계산을 위해 사용되는 연산자
- **`+`** : 덧셈
- **`-`** : 뺄셈
- **`*`** : 곱셈
- **`/`** : 나눗셈
- **`//`** : 몫 나눗셈
- **`%`** : 나머지
- **`**`** : 지수 (거듭제곱)
- **`-`** : 음수 부호

복합 연산자 : 연산과 할당이 함께 이뤄짐
- **`+=`** : a = a + b
- **`-=`** : a = a - b
- **`*=`** : a = a * b
- **`/=`** : a = a / b
- **`//=`** : a = a // b
- **`%=`** : a = a % b
- **`**=`** : a = a ** b

비교 연산자 : 두 값을 비교하여 그 관계가 맞는지 틀리는지를 True / False로 반환
- **`<`** : 미만
- **`<=`** : 이하
- **`>`** : 초과
- **`>=`** : 이상
- **`==`** : 같음
  - **값(데이터)이 같은지** 비교. **동등성 (equality)**
  - 두 변수가 가리키는 객체의 내용, 값(value)이 같은지를 확인.
- **`!=`** : 같지 않음
- **`is`** : 같음
  - **객체 자체가 같은지**를 비교. **식별성 (identity)**. 두 변수가 완전히 동일한 객체를 가리키는지, 즉 **메모리 주소가 같은지를 확인**할 때 사용.
  - 두 변수가 완전히 동일한 메모리 주소의 객체를 가리키는지. 정체적(identity)이 같은지를 확인.
  - 싱글턴 객체를 비교할 때 사용.
    - **싱글턴 (Singleton) 객체** : 특정 값에 대해 파이썬 전체에서 **단 하나의 객체만 생성되어 재사용**되는 특별한 객체. 프로그램 전체에서 오직 1개만 존재하도록 만들어진 특별한 객체.
      - 여러 변수가 이 값을 가지더라도, 모두 미리 만들어진 하나의 객체를 함께 가리키게 되므로 항상 같은 메모리 주소를 가짐
      - **None, True, False**
- **`is not`** : 같지 않음

```python
# 리스트나 객체 비교 시 주의사항
a = [1, 2, 3]
b = [1, 2, 3]
print(a == b) # True (두 리스트의 값은 동일)
print(a is b) # False (서로 다른 리스트 객체)

# b가 a를 그대로 참조하도록 할 경우
b = a
print(a is b) # True (같은 객체를 가리키므로 True)
```

논리 연산자 : 여러 개의 조건을 조합하거나, True/False 값을 반대로 뒤집을 때 사용
- **and (논리곱)** : 두 피연산자 모두 True인 경우에만, 전체 표현식을 True로 평가. 하나라도 거짓이면 바로 거짓.
  - 연산을 왼쪽에서 오른쪽으로 진행하다가, 처음 만나는 '거짓' 값을 바로 반환.
  - 끝까지 갔는데 모든 값이 '참'이면, 맨 마지막 '참' 값을 반환.
- **or (논리합)** : 두 피연산자 중 하나라도 True인 경우 전체 표현식을 True로 평가. 하나라도 '참'이면 바로 '참'.
  - 연산을 왼쪽에서 오른쪽으로 진행하다가, 처음 만나는 '참' 값을 바로 반환.
  - 끝까지 갔는데 모든 값이 '거짓'이면, 맨 마지막 '거짓' 값을 반환
- **not (논리부정)** : 단일 피연산자를 부정

**단축 평가** : **논리 연산**에서 **두 번째 피연산자를 평가하지 않고 결과를 결정**하는 동작. 컴퓨터가 꼭 필요한 계산만 하고, 결과가 이미 정해졌다면 굳이 뒤에 있는 코드까지 확인하지 않는 것.
  - 코드 실행을 최적화하고, 불필요한 연산을 피할 수 있도록 함. 코드의 흐름을 제어하고, 오류를 방지하며, 간결한 코드를 작성하는 데 매우 유용하게 사용되는 기능.

파이썬의 '참 (True)'와 '거짓(False)'에 대한 시각 : 
- 거짓으로 취급되는 값들 : False, 숫자 0, 빈 문자열 "", 빈 리스트 [], None 등 
- 참으로 취급되는 값들 : True 그리고 '거짓'이 아닌 모든 값. 1, -10, 'hello' 등 내용이 있는 값

멤버십 연산자 : 특정 값이 시퀀스나 다른 컬렉션 안에 포함되어 있는지 확인하는 연산자
- **`in`** : 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하는지를 확인.
- **`not in`** : 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하지 않는지를 확인.

```python
word = 'hello'
numbers = [1, 2, 3, 4, 5]

print('h' in word) # True
print('z' in word) # False
print('4' not in numbers) # False
print('6' not in numbers) # True
```

시퀀스형 연산자 : 시퀀스 자료형 (문자열, 리스트, 튜플)에 특별한 의미로 사용되는 연산자
- **`+`** : 결합 연산자
- **`*`** : 반복 연산자

```python
print('Gildong' + 'Hong') # Gildong Hong
print([1, 2] * 2) # [1, 2, 1, 2]
```

**연산자 우선순위** : 
1. **`()`** : 소괄호 grouping
2. **`[]`** : 인덱싱, 슬라이싱
3. **`**`** : 거듭제곱, 지수
4. **`+, -`** : 단항 연산자 양수/음수
5. **`*, /, //, %`** : 산술 연산자
6. **`+, -`** : 산술 연산자
7. **`<, <=, >, >=, ==, !=`** : 비교 연산자
8. **`is, is not`** : 멤버십 연산자
9. **`not`** : 논리 부정
10. **`and`** : 논리 AND
11. **`or`** : 논리 OR

### Trailing Comma

**Trailing Comma (후행 쉼표)** : 컬렉션의 마지막 요소 뒤에 붙는 쉼표
- 일반적으로는 '선택사항'이나, 하나의 요소로 구성된 튜플을 만들 때는 필수임.
- 각 요소를 별도의 줄에 작성 후, 마지막 요소 뒤에 trailing comma 추가. 닫는 괄호는 새로운 줄에 배치.
- 가독성 향상 : 각 줄이 동일한 패턴을 가지며, 코드 리뷰가 용이함.
- 유지보수 용이성 : 항ㄴ목 추가/제거가 간단. 실수로 인한 구문 오류 방지.

```python
x = (1,) # 튜플s

config = {
  'host' : 'localhost',
  'port' : 8000,
  'debug' : True,
}
```
