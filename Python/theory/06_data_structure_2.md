## 비시퀀스 데이터 구조

### 딕셔너리

**딕셔너리 dictionary** : 키 key 와 값 value을 짝지어 저장하는 자료구조

- 내부적으로 **해시테이블**을 사용하여 **키-값 쌍**을 관리함
- 키를 통한 값의 **삽입, 삭제, 검색**이 **매우 빠름**
- **키 key** : **hashable**한 **고유값.** 중복 불가.
- **값 value** : **중복이 가능**하며, **어떤 자료형도 저장**할 수 있음

딕셔너리 메서드:

- **`D.get(key[,default])`** : **키 key에 연결된 값을 반환** (키가 없으면 None을 반환)
    - **key가 없을 때 → None을 반환**
- **`D.get(key, v)`** : 키 key에 연결된 값을 반환하거나 키가 없으면 기본 값으로 v를 반환
- **`D.keys()`** : 딕셔너리 D의 **키를 모은 객체**를 반환
    - `dict_keys(['name', 'age'])` : 실시간으로 동기화 되는 확인 창 (view). 딕셔너리의 **키가 바뀌면 실시간으로 반영**이 됨.
- **`D.values()`** : 딕셔너리 D의 **값을 모은 객체**를 반환. **바뀌면 실시간으로 반영**이 됨.
- **`D.items()`** : 딕셔너리 D의 **키/값 쌍을 모은 객체**를 반환. **바뀌면 실시간으로 반영**이 됨.
    - return → `(key, value)`로 된 튜플이기 때문에, **반복문 시, 2개의 인자 필요**
- **`D.pop(key[,default])`** : 딕셔너리 D에서 키 **key를 제거**하고 연결됐던 **값을 반환** (**없으면 에러/default 반환**)
- **`D.pop(k, v)`** : 딕셔너리 D에서 키 key를 제거하고 연결됐던 값을 반환 (없으면 v를 반환)
- `D.clear()` : 딕셔너리 D의 **모든 키/값 쌍을 제거** → 빈 딕셔너리가 된다
- `D.setdefault(key[,default])` : 딕셔너리 D에서 **키 key와 연결된 값을 반환**. **키가 없다면 default와 연결한 키를 딕셔너리에 추가하고 default를 반환**
- `D.setdefault(k, v)` : 딕셔너리 D에서 키 key와 연결된 값을 반환. key가 D의 키가 아니면 값 v와 연결된 키 key를 D에 추가하고 v를 반환
- `D.update([other])` : other가 제공하는 키/값 쌍으로 **딕셔너리를 갱신하고 기존 키는 덮어씀**. other 내 각 키에 대해 D에 있는 키면 D에 있는 그 키의 값을 other에 있는 값으로 대체. other에 있는 각 키에 대해 없는 키면 키/값 쌍을 D에 추가.

[다양한 딕셔너리 메서드](https://docs.python.org/3.11/library/stdtypes.html#dict)

### 세트

**세트 set** : **고유한 항목**들의 **정렬되지 않은** 컬렉션

- 내부적으로 **해시 테이블을 사용**하여 **데이터를 저장**함
- 항목의 **고유성을 효율적으로 보장**하며, 항목의 **추가, 삭제, 존재 여부 확인 (in 연산)**이 데이터의 크기에 관계없이 **매우 빠름**
- 합집합 union, 교집합 intersection, 차집합 difference 등 **수학적인 집합 연산을 간편하게 수행**할 수 있음
- 중복 제거를 위해 **리스트 → 세트 → 리스트**를 하는 것은 **순서가 유지되지 않음** (대부분의 문제는 순서 유지를 요구함)

세트 메서드 : 

- **`s.add(x)`** : 세트 s에 항목 **x를 추가**. 이미 x가 있다면 변화 없음
- `s.update(iterable)` : 세트 s에 **다른 iterable 요소**를 추가. 중복되는 것은 빼고 추가
- `s.clear()` : 세트 s의 **모든 항목을 제거.**
    - 빈 세트 → `set()`
- **`s.remove(x)`** : 세트 s에서 **항목 x를 제거**. **항목 x가 없을 경우 Key Error**
- `s.pop()` : 세트 s에서 **임의의 항목을 반환**하고, 해당 항목을 **제거**
- `s.discard(x)` : 세트 s에서 **항목 x를 제거**. remove와 달리 **에러 없음**

세트 집합 메서드 : 

- `s1.difference(s2)` : 차집합 `set1 - set2`
- `s1.intersection(s2)` : 교집합 `set1 & set2`
- `s1.union(s2)` : 합집합 `set1 | set2`
- `s2.issubset(s1)` : s2가 s1의 하위집합인지 판별 `set1 <= set2`
- `s1.issuperset(s2)` : s1가 s2의 상위집합인지 판별 `set1 >= set2`

## 해시 테이블

**해시테이블 hash table** : 키 key와 값 value를 짝지어 저장하는 자료구조

- hashable (해시가 가능한 객체)만 저장 가능

해시 테이블의 원리 : 

1. 키를 **해시 함수를 통해 해시 값으로 변환**
2. 변환된 **해시 값을 인덱스로 삼아** 데이터를 저장하거나 찾음
3. 검색, 삽입, 삭제를 매우 빠르게 수행

**해시 hash** : 임의의 크기를 가진 데이터를 고정된 크기의 고유한 값으로 변환하는 것

- **생성된 해시 값(고유한 정수)**는 해당 **데이터를 식별하는 ‘지문’의 역할**
- 파이썬에서는 해시 값을 통해 해시 테이블에 데이터를 저장

**해시 함수 hash function** : 해시 알고리즘. **임의 길이 데이터를 입력** 받아 **고정 길이(정수)로 변환**해 주는 함수. 이 ‘정수’가 바로 **해시 값**

- 해시 테이블 구현 시, 매우 빠른 검색 및 데이터 저장 위치 결정을 위해 활용

해시 테이블이 매우 빠른 이유 : 해시 함수는 **키 key를 입력받아** 데이터를 저장하거나 찾을 배열의 **‘정확한 인덱스’를 즉시 계산함**

set의 요소 & dict의 키와 해시 테이블 관계 : 

- set : **순서를 보장하지 않음**
    - 각 요소를 해시 함수로 변환해 나온 **해시 값에 맞춰 해시 테이블 내부 버킷(bucket)에 위치**시킴 → **버킷 위치 (인덱스)가 요소의 위치를 결정**
- dict : 키 key → 해시 함수 → 해시 값 → 해시 테이블에 저장
    - **“삽입 순서”를 유지**하며, **키를 추가한 순서대로 반복문 순회**할 때 나오게

set의 pop 메서드 : 

- 정수 : **정수(숫자) 값은 해시 값이 숫자 자기 자신과 동일하거나 단순 계산으로 고정됨**
        
- 문자열 : 해시 계산시, 파이썬의 해시 난수화 (Hash Randomization)이 적용됨. 실행마다 순서가 달라짐.
        

파이썬에서의 해시 함수 : 

- 정수 : **같은 정수는 항상 같은 해시 값**을 가짐
- 문자열 : 보안상 이유로 해시 난수화 도입하며, 파이썬 인터프리터 시작때 설정되는 **난수 시드 seed**가 달라짐 → ‘a’의 해시값도 매일 달라짐
    - 함수의 재료 값 난수 시드가 계속 해시값을 바꿈

**해시 난수화**와 난수 시드 : 파이썬 **프로세스가 새로 시작될 때마다 해시를 계산할 때, 사용하는 난수 시드가 달라짐** → 해시 계산에 쓰이는 시드 값이 실행마다 달라짐 → 동일한 데이터라도 **매번 해시 값이 달라져 결과적으로 버킷 배치가 달라짐**

set의 요소 & dict의 키와 해시테이블 관계 : set의 pop()은 “임의의 요소”를 제거하고 반환함.

hashable : hash() 함수에 넣어 해시 값을 구할 수 있는 객체를 의미. 해시 함수를 통해 고유한 해시 값을 만들 수 있고, 값이 변하지 않는 객체.

- 대부분의 불변 타입은 해시 가능  int, float, str, tuple (내부에 불변만 있는경우)
- **가변형 객체는 기본적으로 해시 불가능** : **값이 변하면 해시 값도 달라질 수 있기 때문** (테이블 무결성이 깨짐)

hashable 객체가 필요한 이유 : 

1. 해시 테이블 기반 자료 구조 사용 : set의 요소, dict의 키
    - 중복 방지 & 빠른 검색, 조회
2. 불변성을 통한 일관된 해시 값 : 한 번 해시 값이 정해지면 바뀌지 않아야 해시 테이블 무결성이 유지
3. 안정성과 예측 가능성 유지 : 동일한 데이터는 항상 동일한 해시 값을 반환 → 로직 단순화

## 파이썬 문법 규격

BNF Backus-Naur Form : 프로그래밍 언어의 문법을 표현하기 위한 표기법

- 서로 다른 프로그래밍 언어, 데이터 형식, 프로토콜 등의 문법을 통일하여 정의하기 위함
- 함수나 메서드의 파라미터를 설명할 때도 널리 사용됨
- 대괄호 `[]` 안에 있는 파라미터는 선택 사항
- 문서만 보고도 어떤 파라미터를 필수로 넣어야 하고, 어떤 파라미터를 생략할 수 있는지 한 눈에 파악할 수 있

EBNF Extended Backus-Naur Form : BNF를 확장한 표기법. 메타기호를 추가하여 더 간결하고 표현력이 강해진 형태

EBNF 메타 기호 : 

- **`[]` : 선택적 요소**
- **`{}` : 0번 이상 반복**
- **`()` : 그룹**